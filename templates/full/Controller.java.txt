package ${javaPackage}.controller;


import ${javaPackage}.model.dto.${className}DTO;
import ${javaPackage}.model.entity.${className};
import ${javaPackage}.model.enums.*;
import ${javaPackage}.service.${className}Service;
import io.swagger.annotations.Api;
import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.net.URI;
import javax.validation.Valid;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * <p>Title         : ${className}Controller
 * <p>Project       : ${javaProjectName} : ${projectDescription}
 * <p>Description   : Controller class for ${className}. ${classDescription}
 *
 * @author Kasun Madurasinghe
 * @version 1.0
 */
@Api(basePath = "/${classURL}", value = "${className}Controller", description = "All services related to ${className}Controller", produces = "application/json")
@RestController
@CrossOrigin
@RequestMapping("/${classURL}")
public class ${className}Controller {
    @Autowired
    private ${className}Service ${classVariableName}Service;
    private ModelMapper modelMapper = new ModelMapper();
    private Logger logger = LoggerFactory.getLogger(${className}Controller.class);

    public ${className}Controller(){
        modelMapper.getConfiguration().setMatchingStrategy(MatchingStrategies.LOOSE);
    }

    /** ------------- Main service method ------------- */

    /**
     * get all ${classVariableName}s
     * @return ResponseEntity<List<${className}DTO>>
     */
    @GetMapping(path = "")
    public ResponseEntity<List<${className}DTO>> get${className}s(){
        logger.debug("Request to get all ${classNameDisplay}");
        List<${className}DTO> ${classVariableName}s = ${classVariableName}Service.get${className}s().stream().map( ${classVariableName} -> convertToDTO(${classVariableName})).collect(Collectors.toList());
        if(${classVariableName}s == null) return new ResponseEntity(HttpStatus.NOT_FOUND);
         else return new ResponseEntity(${classVariableName}s, HttpStatus.ACCEPTED);
    }

    /**
     * Get a specific ${classVariableName} by id
     * @param id Long
     * @return ResponseEntity<${className}DTO>
     */
    @GetMapping(path = "{id}")
    public ResponseEntity<${className}DTO> get${className}s(@PathVariable Long id) {
        logger.debug("Request to get a ${classNameDisplay} by id");
         if(id == null || id <= 0) return new ResponseEntity(HttpStatus.PRECONDITION_FAILED);
        Optional<${className}> ${classVariableName} = ${classVariableName}Service.getByID(id);
        if(${classVariableName} != null && ${classVariableName}.isPresent()) return new ResponseEntity(convertToDTO(${classVariableName}.get()) , HttpStatus.ACCEPTED);
        return new ResponseEntity(HttpStatus.NOT_FOUND);
    }


    /**
     * Persist ${classVariableName}. if id > 0 is present expects valid ${classVariableName} object already present, and update it by
     * replacing values. Otherwise simply creates a new ${classVariableName} and id is returned
     * @param ${classVariableName} ${className}DTO
     * @return ResponseEntity<Long>
     * @throws Exception
     */
    @PostMapping(path = "")
    public ResponseEntity<Long> save${className}(@RequestBody @Valid ${className}DTO ${classVariableName}) throws Exception{
        logger.debug("Request to save ${classNameDisplay}");
        ${className} existing${className} = new ${className}();
        if(${classVariableName}.getId() != null && ${classVariableName}.getId() > 0) {
            //In case not all persistent attributes not present in update DTO
            Optional<${className}> saved${className} = ${classVariableName}Service.getByID(${classVariableName}.getId());
            if(saved${className}.isPresent()) existing${className} = saved${className}.get();
            else{
                logger.error("${classNameDisplay} with id " + ${classVariableName}.getId() + " is not present, yet ${classVariableName} is trying to update");
                return new ResponseEntity(HttpStatus.NOT_FOUND);
            }
        }
         ${className} save${className} = copyTo${className}(${classVariableName}, existing${className});
            ServiceStatus serviceStatus = ${classVariableName}Service.save${className}(save${className});
         if(serviceStatus == ServiceStatus.SUCCESS){
            return  ResponseEntity.created (new URI("/${classURL}/" + save${className}.getId())).body(save${className}.getId());
        }else if(serviceStatus == ServiceStatus.INVALID_PARAMS){
            logger.error("Unable to save ${classVariableName} with id " + save${className}.getId() + " as parameters invalid");
            return new ResponseEntity(-1, HttpStatus.EXPECTATION_FAILED);
        }
        logger.error("Unable to save ${classVariableName} with id " + save${className}.getId());
        return new ResponseEntity(-1, HttpStatus.EXPECTATION_FAILED);
    }

   /**
     * Delete a ${classVariableName} by id
     * @param id Long
     * @return ResponseEntity<Long>
     */
    @DeleteMapping("{id}")
    public ResponseEntity<Long> delete(@PathVariable("id") Long id) {
        logger.debug("Request to save ${classNameDisplay} with id " + id);
        if(id == null || id == 0)  return new ResponseEntity(-1, HttpStatus.EXPECTATION_FAILED);
        ServiceStatus serviceStatus = ${classVariableName}Service.deleteByID(id);
        if(serviceStatus == ServiceStatus.SUCCESS) {
            return new ResponseEntity<Long>(id,new HttpHeaders(), HttpStatus.ACCEPTED);
        }else if(serviceStatus == ServiceStatus.INVALID_PARAMS){
            logger.error("Unable to delete ${className} with id " + id + " as parameters invalid");
            return new ResponseEntity(-1, HttpStatus.EXPECTATION_FAILED);
        }
        logger.error("Unable to save ${className} with id " + id );
        return new ResponseEntity(-1, HttpStatus.EXPECTATION_FAILED);

    }
    /** ------------- Private supportive method ------------- */

    private ${className}DTO convertToDTO(${className} ${classVariableName}){
        return modelMapper.map(${classVariableName}, ${className}DTO.class);
    }

    private ${className} convertTo${className}(${className}DTO ${classVariableName}DTO){
        return modelMapper.map(${classVariableName}DTO, ${className}.class);
    }

    private ${className} copyTo${className}(${className}DTO ${classVariableName}DTO, ${className} ${classVariableName}){
         modelMapper.map(${classVariableName}DTO, ${classVariableName});
          return ${classVariableName};
    }

}
